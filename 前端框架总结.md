## vue

### 基本语法

#### 安装引入

```html
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>

<!-- 支持原生ES Modules时 -->
<script type="module">
  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js'
</script>
```

vue模块在不同模块规范下有相对应不同的模块可下载，且每种规范下，有分有完整版与运行时版。

- **完整版**：同时包含编译器和运行时的版本。
- **编译器**：用来将模板字符串编译成为 JavaScript 渲染函数的代码。
- **运行时**：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。

```javascript
// 需要编译器
new Vue({
  template: '<div>{{ hi }}</div>'
})

// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```

####  实例创建

```vue
/*逻辑层*/
<script>
var data = { message: 'Hello'}
Object.freeze(data)//使得属性不可被修改，响应系统无法再追踪变化
var vm = new Vue({
  	el: '#example',
  	data: data,
    created: function () {
    	// `this` 指向 vm 实例
    	console.log('message is: ' + this.message)
    },
    computed: {
    	// 计算属性的 getter
    	reversedMessage: function () {
      		// `this` 指向 vm 实例
      		return this.message.split('').reverse().join('')
    	}
        //可以自行定义set和get方法
        //set :function(){}
        //get :function(){}
  	},
    methods: {
  		reversedMsg: function () {
    		return this.message.split('').reverse().join('')
  		}
	},
    watch: {
    	reversedMessage: function () {
      		this.msg = this.message.split('').reverse().join('')
    	}
  	}
})
vm.a == data.a //true

</script>

/*显示数据*/
<p>{{ message }}</p>
<p>{{ reversedMessage }}</p>
<p>{{ reversedMsg() }}</p>
<p>{{ msg }}</p>
```

虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。 

在创建这个实例时，传入参数，通过控制参数来控制渲染一个组件。

* data： 当一个 Vue 实例被创建时，它将 `data` 对象中的所有的属性加入到 Vue 的**响应式系统**中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 
* el：绑定的元素
* created：声明周期，初始化后执行
* mounted：创建vm.$el后并替换el后执行
* updated：数据更新完后执行
* destoryed：销毁完毕后执行
* computed：先进行逻辑计算再渲染。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。例如如果计算` return Date.now() `变量将不会变化。
* methods:  每当触发重新渲染时，调用方法将总会再次执行函数 
* watch：  Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性 

#### 模板语法

```html
<!--显示文本-->
<span>Message: {{ msg }}</span>
<!--显示html语句-->
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 

```html
<p v-if="seen">现在你看到我了</p>
<a v-bind:href="url">...</a><a :href="url">...</a>
<a v-on:click="doSomething">...</a><a @click="doSomething">...</a>
```

* v-if：通过判断参数的真假来决定是否插入p元素
* v-bind：绑定元素本身属性，简写为`:`
* v-on：绑定事件,简写为`@`

此外，{{}}中可以写入简单的javascript运算即方法调用

```javascript
{{ message.split('').reverse().join('') }}
```

#### 绑定class与style

```html
<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
```

此为用对象定义class。其表示active这个属性是否有效在于isActive的真假，且可以和class并存。

```vue
<div v-bind:class="[activeClass, errorClass]"></div>
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

此为用数组定义class。

style与class使用方法相似。

#### 条件渲染

```vue
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

通过判断loginType来判断渲染的元素，key来对元素命名确保元素的唯一性。

```html
<h1 v-show="ok">Hello!</h1>
```

 不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS 属性 `display`。 

#### 列表渲染

```html
<!--遍历数组-->
<ul id="example-1">
  <li v-for="(item, index) in items">
    {{ item.message }}
  </li>
</ul>

data: {
  items: [
    { message: 'Foo' },
    { message: 'Bar' }
  ]
}

<!--遍历对象-->
<ul id="v-for-object" class="demo">
  <li v-for="(value, name, index) in object">
    {{ index }}. {{ name }}: {{ value }}
  </li>
</ul>

data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
}



```

##### 显示过滤或者排序后的结果

```html
<li v-for="n in evenNumbers">{{ n }}</li>

data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
```

#### 事件处理

在methods中写入自定义方法，在v-on后面调用。

```vue
<div id="example-2">
  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>
<script>
var example2 = new Vue({
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// 也可以用 JavaScript 直接调用方法
example2.greet() // => 'Hello Vue.js!'
</script>
```



##### 事件修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```

#### 表单输入绑定

 你可以用 `v-model` 指令在表单 ``、`` 及 `` 元素上创建双向数据绑定。  `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 

##### 文本

```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

##### 多行文本

```html
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

##### 复选框

当单个选中时，会将选中的内容添加到checkedNames的数组中。

```html
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>Checked names: {{ checkedNames }}</span>
</div>
<script>
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
</script>
```



##### 单选按钮

```html
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
<script>
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
</script>
```



##### 选择框

```html
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
<script>
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
</script>
```

##### 绑定值

例如当选中复选框的时候想数组添加的是yes，而非选中的内容。

```html
<!--选中时向toggle中添加yes-->
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no"
>
<!--选中时向vm.pick等于vm.a-->
<input type="radio" v-model="pick" v-bind:value="a">
<!--选中时向vm.selected.number添加123 -->
<select v-model="selected">
  <option v-bind:value="{ number: 123 }">123</option>
</select>


```

##### 修饰符

* lazy: 在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://vuejs.bootcss.com/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转变为使用 `change` 事件进行同步： 
* number: 如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符
* trim: 如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符 

```html
<input v-model.trim="msg">
```

### 组件

#### 组件注册

在组件中data需要为一个函数，这样可以保证每次调用组件时创建新的data对象。

###### 全局注册

```javascript
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})

Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })
```

 我们可以在一个通过 `new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 

```html
<div id="components-demo">
  <button-counter></button-counter>
</div>

<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```



###### 局部注册

如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 

对于 `components` 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 

```html
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
<!--然后在 components 选项中定义你想要使用的组件-->
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```







#### 向子组件传值

通过props来传递值

```vue
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
})


<blog-post title="My journey with Vue"></blog-post>
<blog-post title="Blogging with Vue"></blog-post>
<blog-post title="Why Vue is so fun"></blog-post>
```

#### 监听子组件事件

通过  `postFontSize` 数据属性来监听事件

```vue
<!--父组件监听自定义的事件-->
<blog-post
  ...
  v-on:enlarge-text="postFontSize +=  $event"
></blog-post>
<!--子组件创建一个自定义的事件-->
<button v-on:click="$emit('enlarge-text', 0.1)">
  Enlarge text
</button>
```

#### 动态组件

```html
<!-- 组件会在 `currentTabComponent` 改变时改变 -->
<component v-bind:is="currentTabComponent"></component>
<!-- 失活的组件将会被缓存！-->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>

```

### 路由









## react

## angular

### 工程总览

#### 工程创建

```shell
npm i @angular/cli
ng new project_name   ##创建名为project——name的项目
ng new project_name --skip-install --style css --routing false  ##只生成文件不下载依赖
ng serve   ##启动服务
ng build   ##打包
ng lint ##扫描代码
ng g c component/component_name  ## 创建新的组件
ng g m Home --routing##创建路由模块
ng add ng-zorro-antd ##ui库

```

#### 项目目录

```
--e2e  测试目录
--src  源码目录
----assets  资源目录（存放图片，音频等）
----environments  环境目录
----app  主要逻辑代码目录
--editorconfig  编码风格设置
--angular.json  项目的定义文件
--browserslist  浏览器兼容设置(css)
--karma.conf.js  测试文件
--tsconfig.*  ts配置文件
--tslint.json  静态代码扫描
--polyfills.ts  浏览器兼容设置(js)
```

#### 项目结构

项目是由一个个模块构成的。每个模块包括该模块内容与相对应的路由模块。模块内容包括一个个组件、指令、管道、服务。

模块分为根模块，普通模块，共享模块。

```
--根模块---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-根路由模块
|-模块一---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-负责模块一的路由模块
|-模块二---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-负责模块二的路由模块
|-共享模块---公用组件一、公用指令一、公用管道一
	     |--公用组件二、公用指令二、公用管道二
```



以下是模块与组件的关系，组件是最小渲染单元。

```javascript
//在app.module.ts中，配置所有组件
@NgModule({
  declarations: [//本模块中含有的组件
    AppComponent
  ],
  imports: [//依赖的其他模块
    BrowserModule
  ],
  providers: [],//对内需要暴露的服务
  bootstrap: [AppComponent]//启动的根组件，入口组件
})
```

而一个项目通常是由多个模板组成的。

#### 脏值检测

###### 定义

脏值检测是angular的一个基本机制，他保证了当angular的数据变化时可以更新视图。

###### 触发脏值检测的条件

* 浏览器事件，例如click，mouseover，keyup

* setTimeout和setInterval

* HTTP请求

###### 如何进行脏值检测

他将组件按照嵌套关系生成以可组件树，递归的查询每棵树上的绑定数据的值，如果有变化则更新视图。

在有父组件和子组件的生命周期中

```
子组<------更新输入型属性
      |---OnInit，DoCheck，OnChanges
      |   更新dom--------->父组件
      |---脏值检测（完成后会引发下面的周期）
      |---AfterViewCheck，AfterViewInit
```

脏值检测的时候，angular会从跟组件开始循环遍历，查看所有绑定数据的属性值有没有变化，且进行两次。

这也指明了我们不能在AfterViewCheck，AfterViewInit中对绑定的数据进行更改，因为如果在此更改后，脏值检测完成后，触发AfterViewCheck事件更改了值，紧接着触发第二次脏值检测，检测到值不一样了会抛出异常。

###### 默认策略与onpush策略

以上说的为默认政策，默认政策时，脏值检测当出发的时候会递归的查询所有组件，有时候可能会影响性能。onpush政策可以使当触发脏值检测的时候，只检查本组件的input变量有没有变化而忽略其他的改变。而input变量有来自于组件外，所以，将组件设置为onpush政策使得该组件变成了一个笨组件(木偶组件)，只用于单纯的展示。

要设置成onpush策略我们要在组件逻辑ts中加入如下：

```javascript
@Component({
	changeDetection:ChangeDetectionStrategy.onpush
})
```

但需要主义的使，路由的参数变化在默认策略之下，不会销毁这个组件而是重用这个组件，所以ngOnInit（我们默认数据的获取写在这里）只走一遍，这在默认模式下面没有问题，但在onpush模式下会被忽略，从而导致在改变路由参数之后，再改回来的时候，数据会无法获取到。

解决方法，我们将`private cd:ChangeDetectorRef`引入到类中，通过再函数末尾使用`this.cd.markForCheck()`来告诉组件此处发生了变化，需要更新数据。

### angular基础知识

#### 条件渲染

*ngFor：循环渲染

```html
<ul>
	<li *ngFor="let menu of menus;
		let i=index;  //索引
		let first=first;  //是否为第一个元素
        let last=last;   //是否为最后一个元素
        let odd=odd;   //是否为第奇数个
        let even=even;   //是否为第偶数个
        trackBy:trackElement;   //提升性能，后面借一个表达式或者函数
    " >
        <a herf="#">{{menu.title}}</a>
	</li>
</ul>
```

*ngIf：判断渲染

```html
<div *ngIf="条件">
    条件为真的内容
</div>

<div *ngIf="条件" else elseContent>
    条件为真的内容
</div>
<ng-template #elseContent>
    条件为假的内容
</ng-template>
```

#### 事件绑定

```html
<a
   herf="#"
   (click)='function(){}'
   >
</a>
```





#### 样式绑定

* 第一种：当后面的表达式成立，`.active`样式生效。适用于单个样式

  ```html
  <a
     herf="#"
     [class.active]="selectedIndex===i"
     >
  </a>
  ```

* 第二种：自由度拓展性最强的绑定方法

  ```html
  <a
     [ngClass]="{'active':true,'first':false}"
  ></a>
  ```

* 第三种：嵌入式样式，会覆盖其他样式。常用于动态改变某个css属性。

  ```html
  <a
  	[ngStyle]="{'color':somecolor,'font-size':somesize}"   
  ></a>
  ```

* 第四种：js操作dom去绑定(不推荐使用)

* 第五种：js使用rd2去绑定

  ```javascript
  (private elr:ElementRef,private rd2:Renderer2)=>{
  	this.rd2.setStyle(this.elr.nativeElement,'display','grid')
  }
  ```

eg：

* 在组件中有一个伪类`:host`,他的属性定义会应用到他的宿主（也就是他所在的组件本身），而不是模板中的元素。

#### 依赖注入

当我们定义一个类之后，想要应用这个类中的方法，就比如通过new一个他的实例然后使用。但是如果该类被标记了注入服务，那么我们在声明他的时候就不用在通过new去创建实例，而是可以直接声明类型后去使用。此时该类也变成了单利模式。

```javascript
@Injectable()//声明可注入
class Product{
    constructor(private name:string){}
}
@Injectable()
class PurchaseOrder{
    private product:Product;
    constructor(private product:Product){}
}

ngOnInit(){
    const injector=Injector.create({
        //在声明自己函数后，在此将自己的函数创建实例，供别人直接使用
        providers:[//依赖池：在此声明所有需要供用的函数
            {
                provide:Product,//标识符
                useFactory:()=>{
                	return newProduct('haha')
            	}
            },{
                provide:PurchaseOrder,
                useClass:Product,//去new的东西
                deps:[Product]本类中依赖的类
            }
        ]
    })
    console.log(this.injector.get(Product))//可以通过js方式获取该类
}


//此后如果我想用Product类，可以直接通过private product:Product的方式，而不用new了。
```

在angular中提供了更为简单的方式，不用我们自己通过`Injector.create`自行构造的，再将类暴露出去之后，可以直接通过在模块中设置providers属性中设置。

```javascript
@NgModule({
	declarations:[],
	providers:[
		PurchaseOrder,//如果无需工厂设置可以直接只写一个类名
		{
			provide:Product,
			useFactory:()=>{
				return newProduct('haha')
			}
		}
	],
	imports:[]
})
```

除了在模块中自己设置angular6以后的版本中还有一种更简单的设置方法，直接在服务创建的时候自行声明

```javascript
@Injectable({
    providedIn: 'root' //root代表跟模块，也可以指定模块
})
export class Product{
    constructor(private name:string){}
}
```

如果我们要提供的不是一个具体的类，而是一个值，我们可以这么写

```javascript
const injector=Injector.create({
        providers:[
            {
                provide:'baseUrl',
                useValue:'http://localhost'
            }
        ]
})
this.injector.get('baseUrl')
```

但是在大型项目中，使用字符串做名字是很危险的，极有可能造成命名重复，所以我们创建一个token来确保他的唯一性

```javascript
const token=new InjectionToken<string>('baseUrl')
const injector=Injector.create({
        providers:[
            {
                provide:token,
                useValue:'http://localhost'
            }
        ]
})
this.injector.get(token)
//此后如果我想用这个字符串，可以这样声明：
//@Inject(token) private baseurl:string
```









### 组件

#### 组件的封装

* 通过` ng g c component_name`生成新的组件

* 在新生成的组件中创建index.ts并暴露此组件

* 在使用的组件中引入组件

* 组件可以使用其ts文件中selector作为名字在其他地方直接使用

* 结构目录如下

  ```
  ---component
  	---index.ts
  	---scrollable
  		---index.ts
  		---scrollable.component.css
  		---scrollable.component.html
  		---scrollable.component.ts
  		---scrollable.component.spec.ts
  	---app.component.css
  	---app.component.html
  	---app.component.ts
  	---app.component.spec.ts
  	---app.module.ts
  
  ```

#### 组件的通讯

##### 子组件--->父组件  事件绑定

在子组件中

```javascript
export class ChildComponent {
    index:-1;
  	@Output() tabSelected=new EventEmitter();
  	handleSelect(index){
        this.tabSelected.emit(index)
  		 	
  	}
}
```

在父组件中

```html
<child_component (tabSelect)="handleTabSelected($event)"></child_component>

export class AppComponent {
  	handleTabSelected(index){
		console.log(index)
	}
}

```

##### 父组件--->子组件  属性绑定

在父组件中

```html
<!--定义变量-->
export class AppComponent {
  menus=[1,2,3]
}
<!--将menus变量传给子组件-->
<child_component [data]='menus'></child_component>
```

在子组件中

```html
<!--接收变量-->
export class ChildComponent {
  @Input() data=[]
}
<!--使用变量-->
<ul>
    <li *ngFor="let menu of data;">
		{{menu}}
    </li>
</ul>
```

#### 组件的生命周期



组件在使用前需要继承相关接口

```javascript
export class ScrollableTabComponent implements OnInit {//需要先继承
  constructor() { }
  ngOnInit() {
  }
}
```

#### 组件的投影

```html
<!--父组件中-->
<child_component>
	<p>
        hello
    </p>
</child_component>
<!--在子组件中，被嵌套的内容会显示在此标签的位置,select选择指定内容显示-->
<ng-content select="样式/html标签/指令"></ng-content>  
```

#### 组件类中引用模板的元素

```html
<!--在模板中,用#做一个唯一标识,一下分别时去一个普通元素，一个自定义元素，多个普通元素-->
<div #helloDiv>
    hello
</div>
<app-image-slider></app-image-slider>
<img #img *ngFor"let a of lists" [src]="a.src"/>
<!--在组件类中使用@ViewChild选择器选择。ElementRef是html的一个包装类-->
export class AppComponent{
	@ViewChild('helloDiv') helloDivRef:ElementRef;
	@ViewChild('ImageSliderComponent') imageSlider:ImageSliderComponent;
	@ViewChildren("img") imgs:QueryList<ElementRef>
    
    handleable(){
		console.log(helloDivRef.nativeElement) //元素本身
	}
}
```

#### 组件的双向绑定

双向绑定最常见的作用就是，在我们更新input输入内容的同时，input的内容会不断更新在另外一处地方。

在此之前我们已经可以达到双向绑定了，通过事件绑定+属性绑定来实现。

```html
<input type="text" [value]="username" (input)="username=$event.target.value">
```

在angular中还有更简单的方法。[(ngModel)]=“变量”，这其实就是一个语法糖。

首先需要引入FormsModule模块。

然后可以简写为

```html
<input type="text" [(ngModel)]="username"> 
```



### 模块

### 服务

### 管道

##### 内建管道

* json管道：`a|json` 转化为json格式

* data管道：`a| data: slice:1:3` 切割第一位到第三位

* date管道：`a| date:'MM-dd'` 将日期转化为月-日的格式

* currency管道：`a|currency 'CNY' :'symbol':'4.0-2'` 使用￥前缀，小数点前4位小数点后两位保留数 

* async管道：异步管道，例子如下

  ```
  
  ```

  

##### 自定义管道

通过`ng-pipe`在vscode中创建模板

```javascript
//设置倒计时管道
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({ name: 'appAgo' })
export class AgoPipe implements PipeTransform {
  transform(value: any): any {
    if (value) {
      const seconds = Math.floor((+new Date() - +new Date(value)) / 1000);
      if (seconds < 29) {
        // 小于 30 秒
        return '刚刚';
      }
      const intervals = {
        年: 3600 * 24 * 365,
        月: 3600 * 24 * 30,
        周: 3600 * 24 * 7,
        天: 3600 * 24,
        小时: 3600,
        分钟: 60,
        秒: 1
      };
      let counter = 0;
      for (const unitName in intervals) {
        if (intervals.hasOwnProperty(unitName)) {
          const unitValue = intervals[unitName];
          counter = Math.floor(seconds / unitValue);
          if (counter > 0) {
            return counter + ' ' + unitName + '前';
          }
        }
      }
    }
    return value;
  }
}

```







### 指令

指令分为三种：

* 组件：特殊的指令，带模板的指令
* 结构型指令（内建指令）：改变dom结构。例如ngIf、ngFor、ngSwitch
* 属性型指令（内建指令）：改变宿主行为。例如ngClass、ngStyle、ngModel



除了使用内建指令，我们还可以自己创建一个指令

```typescript
//创建一个属性指令
import { Directive, HostBinding } from '@angular/core';

/**
 * 指令可以理解为没有模版的组件，它需要一个宿主元素。
 * 推荐使用方括号 [] 指定 Selector，使它变成一个属性。
 */
@Directive({
  selector: '[appGridItem]'
})
export class GridItemDirective implements OnInit{
    contructors(private elr: ElementRef, private renderer: Renderer2){}
    ngOnInit():void {//注意修改属性的方法要放到oninit生命周期里执行 ，而不能放到contructor里面。
        this.rd2.setStyle(this.elr.nativeElement,'display','grid')
    }
}
```



如果单纯使用指令绑定样式和事件，angular提供了更简单的方法。

由于指令没有模板，所以他要寄宿在一个元素之上（宿主），`@HostBinding` 可以绑定宿主的属性或者样式，`@HostListener`可以绑定宿主的事件。

```javascript
export class GridItemDirective {
	@HostBinding('style.display') display = 'grid';
	@HostBinding('style.place-items') align = 'center';
/*
使用hostbinding绑定后，使得宿主的style.display与display变量相关联，同时变化。
*/
	@HostListener('click',['$event.target'])
   	handleClick(ev){console.log(ev)}
/*
使用hostlistener绑定后，第一个参数是事件类型，第二个参数是数组，写入数据依赖，当宿主触发了对一个事件后，会触发指令中的函数方法
*/
}

```









### 路由

##### 基本形式

通过`ng-router-appmodule`创建模板

```typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { RecommendContainerComponent } from './components';

const routes: Routes = [
    {path: '', redirectTo: 'home',pathMatch: 'full'},
    {path: 'home',component: RecommendContainerComponent1},
    {path: '**', component: RecommendContainerComponent2},
];
//''路径表示默认，**表示不识别的路径
@NgModule({
  imports: [RouterModule.forChild(routes)],//在此处导入模块
  exports: [RouterModule]
})
export class RecommendRoutingModule {}


//应用
//<router-outlet></router-outlet>
```

##### 路由的嵌套

当然路由也可以嵌套，加入home下面还有子路由,我们可以再子路由中设置

```typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeContainerComponent, HomeDetailComponent } from './components';

const routes: Routes = [
  {
    path: 'home',
    component: HomeContainerComponent,
    children: [
      {
        /**
         * 路由节点可以没有 component
         * 一般用于重定向到一个默认子路由
         */
        path: '',
        redirectTo: 'hot',
        pathMatch: 'full'
      },
      {
        /**
         * 路径参数，看起来是 URL 的一部分
         */
        path: ':tabLink',
        component: HomeDetailComponent
      }
    ]
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class HomeRoutingModule {}

```

##### 路径参数

拼接在url上面的，叫做路径参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home','/spots']"></a>

this.router.navigate(['home','/spots'])

*url*

http://loaclhost:4200/home/sports

*取读*

this.route.paramsMap.subcribe(params=>{})

##### 路径对象参数

形似`name=val1`的参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home','/spots'，{name:'val1'}]"></a>

this.router.navigate(['home','/spots',{name:'val1'}])

*url*

http://loaclhost:4200/home/sports;name=val1

*取读*

this.route.paramsMap.subcribe(params=>{})

##### 路径查询参数

形似`?name=val1`的参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home']" [queryParms]={name:'val1'}></a>

this.router.navigate(['home'],{queryParms:{name:'val1'}})

*url*

http://loaclhost:4200/home/sports;name=val1

*取读*

this.route.queryParamsMap.subcribe(params=>{})

##### 点击触发样式

我们可以通过`routerLinkActive`属性在标签点击触发路由的时候添加类名

```html
<a 
   [routerLink]="['/home']" 
   [queryParms]={name:'val1'}
   routerLinkActive="active"
></a>
```



### 网络接口对接

##### HttpClient

* 在根模块导入HttpClientModule
* 在构造中注入HttpClient
* 订阅后发送请求

```javascript
//在根模块引入后，在其他模块中也可以使用
export class HomeService{
    constructor(private http:HttpClient){}
    getData(){
        //通过泛型的形式，将他返回的数据进行格式转换，此处可以是string，也可以是其他自行定义的类型
        return this.http.get<string>(url,{
            params:{icode:123}
        })
    }
}
//http是一种异步操作
//这个时候getData返回的数据类型是
//在使用他的时候为
export class Home{
    constructor(private serve:HomeService){}
    let _data='';
    ngOnInit(){
        this.serve.subscribe(tabs=>{
         	this._data=tabs;   
        })
    }
}
```

##### http拦截器 httpInterceptor

在http获取到数据之前，我们先将其进行一步处理，然后再交给httpclient去处理。在请求和访问的时候都可以进行拦截。

在请求中，例如要为很多http请求统一加入一个请求参数而无需一个一个加。

通过`ng-http-interceptor`在vscode中生成模板

```javascript
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest
} from '@angular/common/http';
import { environment } from 'src/environments/environment';

@Injectable()
export class ParamInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    // 对请求消息进行处理
    const modifiedReq = req.clone({
      //将原来的req克隆下来，并为他加入查询参数
      setParams: { icode: environment.icode }
    });
    //交给下一个拦截器去处理，因为在angular中可能有多个拦截器
    return next.handle(modifiedReq);
  }
}
```

完成设置后，我们要在根模块将它引入

```typescript
@NgModule({
  declarations: [AppComponent],
  imports: [],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: NotificationInterceptor,
      multi: true
    }
  ],
  bootstrap: []
})
```



同理，我们也可以拦截请求到的数据，也就是respond的数据。

例如我们要设置，当请求成功的时候弹出消息。

```javascript
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpResponse
} from '@angular/common/http';
import { tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class NotificationInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    // 对响应消息进行处理
    return next.handle(req).pipe(
      tap((event: HttpEvent<any>) => {
        if (
          event instanceof HttpResponse &&
          event.status >= 200 &&
          event.status < 300
        ) {
          console.log('[此处假装弹出消息] 请求成功！');
        }
      })
    );
  }
}
```

完成后同样在根模块引入。

##### rxjs 响应式编程类库

###### 基础概念

rx要把事件或者数据看成一个流，随着事件流中的元素的变化随之做出相应的动作。

流的种类：无线、有限、单个、空

流的状态：next（得到流的数据之后的处理）、error（发生错误的处理）、complete（无论成功与否，最后都要执行的处理）

此外，所有的流都是异步的。

rx中流的类型用`observable`类型来表示。

rx最强大的地方之一，就是他拥有方便的操作符。

###### 操作符

在路由参数接受的时候，我们运用的就是`observable`类型，如下例子

```javascript
paramData;
ngOnInit(){
	this.route.paramMap.subscribe(params=>{
    	this.paramData=params.get('tabLink')
	})
}
```

使用在模板中

```html
<div *ngIf="paramData==='home'">
    <p>
        hello
    </p>
</div>
```



上面的代码中，我们获取到params参数中，获取到tabLink属性，我们也可以添加管道，通过操作符改造。

```javascript
paramData;
ngOnInit(){
    this.route.paramMap
    .pipe(
		filter(params=>params.has('tabLink')),
    	map(params=>params.get('tabLink'))
	)
    .subscribe(tabLink=>{
    	this.paramData=tabLink;
	})
}
```

应用在模板中同上。

但是在angular中，为了更好的兼容rx，我们可以直接将一个变量声明为流

```javascript
//当变量作为流的时候，我们习惯在命名上加上一个$用于区分
paramData$:Observable<string>;
ngOnInit(){
    this.paramData=this.route.paramMap
    .pipe(
		filter(params=>params.has('tabLink')),
    	map(params=>params.get('tabLink'))
	)
}
```

使用在模板中时，由于这是一部操作，所以在一开始的时候paramData和‘home’的数据类型不同，所以我们通过异步管道实现它。

```html
<div *ngIf="(paramData | async)==='home'">
    <p>
        hello
    </p>
</div>
```





## react native

### 项目启动

在电脑装又node10、python2*、sdk、jdk、gradle、nox的环境下

* 直接使用`npx react-native init AwesomeProject `,也可以先下载脚手架`npm -g install react-native-cli`,然后安装项目`react-native  init AwesomeProject ` 
* 确保在nox的bin目录下的nox_adb version与全局下的adb version是一个版本，如不是，则复制过去
* 在命令行输入 nox_adb connect 127.0.01：62001
* 在命令行输入 adb devices
* 进入项目中打包，react-native run-and ,并输入npm start
* 打开nox模拟器，在setting中设置IP为172.17.100.2：8081
* 重启模拟器

再次启动时，直接运行`npm start`然后打开模拟器上的apk就可以了

### 项目介绍

### 基础

##### props属性

函数组件中

```javascript
//<ShowMyName name='夏炜轩'></ShowMyName>

const ShowMyName = (props) => {
    return (
      <>
        <Text>hello 夏炜轩</Text>
        <Text>{props.name}</Text>
      </>
    );
  };
```

类组件中

```

```

##### state状态

函数组件中

类组件中

##### 样式

```jsx
import React, { Component } from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class LotsOfStyles extends Component {
  render() {
    return (
      <View>
        <Text style={styles.red}>just red</Text>
        <Text style={styles.bigBlue}>just bigBlue</Text>
        <Text style={[styles.bigBlue, styles.red]}>bigBlue, then red</Text>
        <Text style={[styles.red, styles.bigBlue]}>red, then bigBlue</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  bigBlue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
  red: {
    color: 'red',
  },
});

```





### 常见标签

* View：相当于div，不可继承样式

* Text：写文本，可继承样式

* Image：显示图片,如果图片来源于网络则必须设置大小

  ```html
  <Image source={require()}/>
  ```

  



















