## vue

### 基本语法

#### 安装引入

```html
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>

<!-- 支持原生ES Modules时 -->
<script type="module">
  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.11/dist/vue.esm.browser.js'
</script>
```

`vue`模块在不同模块规范下有相对应不同的模块可下载，且每种规范下，有分有完整版与运行时版。

- **完整版**：同时包含编译器和运行时的版本。
- **编译器**：用来将模板字符串编译成为 JavaScript 渲染函数的代码。
- **运行时**：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。

```javascript
// 需要编译器
new Vue({
  template: '<div>{{ hi }}</div>'
})

// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```

####  实例创建

```vue
/*逻辑层*/
<script>
var data = { message: 'Hello'}
Object.freeze(data)//使得属性不可被修改，响应系统无法再追踪变化
var vm = new Vue({
  	el: '#example',
  	data: data,
    created: function () {
    	// `this` 指向 vm 实例
    	console.log('message is: ' + this.message)
    },
    computed: {
    	// 计算属性的 getter
    	reversedMessage: function () {
      		// `this` 指向 vm 实例
      		return this.message.split('').reverse().join('')
    	}
        //可以自行定义set和get方法
        //set :function(){}
        //get :function(){}
  	},
    methods: {
  		reversedMsg: function () {
    		return this.message.split('').reverse().join('')
  		}
	},
    watch: {
    	reversedMessage: function () {
      		this.msg = this.message.split('').reverse().join('')
    	}
  	}
})
vm.a == data.a //true

</script>

/*显示数据*/
<p>{{ message }}</p>
<p>{{ reversedMessage }}</p>
<p>{{ reversedMsg() }}</p>
<p>{{ msg }}</p>
```

虽然没有完全遵循 [MVVM 模型](https://zh.wikipedia.org/wiki/MVVM)，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 `vm` (ViewModel 的缩写) 这个变量名表示 Vue 实例。 

在创建这个实例时，传入参数，通过控制参数来控制渲染一个组件。

* data： 当一个 Vue 实例被创建时，它将 `data` 对象中的所有的属性加入到 Vue 的**响应式系统**中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 
* el：绑定的元素
* created：声明周期，初始化后执行
* mounted：创建vm.$el后并替换el后执行
* updated：数据更新完后执行
* destoryed：销毁完毕后执行
* computed：先进行逻辑计算再渲染。计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。例如如果计算` return Date.now() `变量将不会变化。
* methods:  每当触发重新渲染时，调用方法将总会再次执行函数 
* watch：  Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性 

#### 模板语法

```html
<!--显示文本-->
<span>Message: {{ msg }}</span>
<!--显示html语句-->
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

指令 (Directives) 是带有 `v-` 前缀的特殊 attribute。 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 

```html
<p v-if="seen">现在你看到我了</p>
<a v-bind:href="url">...</a><a :href="url">...</a>
<a v-on:click="doSomething">...</a><a @click="doSomething">...</a>
```

* v-if：通过判断参数的真假来决定是否插入p元素
* v-bind：绑定元素本身属性，简写为`:`
* v-on：绑定事件,简写为`@`

此外，`{{}}`中可以写入简单的javascript运算即方法调用

```javascript
{{ message.split('').reverse().join('') }}
```

#### 绑定class与style

```html
<div class="static" v-bind:class="{ active: isActive, 'text-danger': hasError }"></div>
```

此为用对象定义class。其表示active这个属性是否有效在于isActive的真假，且可以和class并存。

```vue
<div v-bind:class="[activeClass, errorClass]"></div>
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

此为用数组定义class。

style与class使用方法相似。

#### 条件渲染

```vue
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

通过判断loginType来判断渲染的元素，key来对元素命名确保元素的唯一性。

```html
<h1 v-show="ok">Hello!</h1>
```

 不同的是带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS 属性 `display`。 

#### 列表渲染

```html
<!--遍历数组-->
<ul id="example-1">
  <li v-for="(item, index) in items">
    {{ item.message }}
  </li>
</ul>

data: {
  items: [
    { message: 'Foo' },
    { message: 'Bar' }
  ]
}

<!--遍历对象-->
<ul id="v-for-object" class="demo">
  <li v-for="(value, name, index) in object">
    {{ index }}. {{ name }}: {{ value }}
  </li>
</ul>

data: {
    object: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
}



```

##### 显示过滤或者排序后的结果

```html
<li v-for="n in evenNumbers">{{ n }}</li>

data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
```

#### 事件处理

在methods中写入自定义方法，在v-on后面调用。

```vue
<div id="example-2">
  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>
<script>
var example2 = new Vue({
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指向当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      if (event) {
        alert(event.target.tagName)
      }
    }
  }
})

// 也可以用 JavaScript 直接调用方法
example2.greet() // => 'Hello Vue.js!'
</script>
```



##### 事件修饰符

```html
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
```

#### 表单输入绑定

 你可以用 `v-model` 指令在表单 ``、`` 及 `` 元素上创建双向数据绑定。  `v-model` 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 

##### 文本

```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

##### 多行文本

```html
<span>Multiline message is:</span>
<p style="white-space: pre-line;">{{ message }}</p>
<br>
<textarea v-model="message" placeholder="add multiple lines"></textarea>
```

##### 复选框

当单个选中时，会将选中的内容添加到checkedNames的数组中。

```html
<div id='example-3'>
  <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
  <label for="jack">Jack</label>
  <input type="checkbox" id="john" value="John" v-model="checkedNames">
  <label for="john">John</label>
  <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
  <label for="mike">Mike</label>
  <br>
  <span>Checked names: {{ checkedNames }}</span>
</div>
<script>
new Vue({
  el: '#example-3',
  data: {
    checkedNames: []
  }
})
</script>
```



##### 单选按钮

```html
<div id="example-4">
  <input type="radio" id="one" value="One" v-model="picked">
  <label for="one">One</label>
  <br>
  <input type="radio" id="two" value="Two" v-model="picked">
  <label for="two">Two</label>
  <br>
  <span>Picked: {{ picked }}</span>
</div>
<script>
new Vue({
  el: '#example-4',
  data: {
    picked: ''
  }
})
</script>
```



##### 选择框

```html
<div id="example-5">
  <select v-model="selected">
    <option disabled value="">请选择</option>
    <option>A</option>
    <option>B</option>
    <option>C</option>
  </select>
  <span>Selected: {{ selected }}</span>
</div>
<script>
new Vue({
  el: '...',
  data: {
    selected: ''
  }
})
</script>
```

##### 绑定值

例如当选中复选框的时候想数组添加的是yes，而非选中的内容。

```html
<!--选中时向toggle中添加yes-->
<input
  type="checkbox"
  v-model="toggle"
  true-value="yes"
  false-value="no"
>
<!--选中时向vm.pick等于vm.a-->
<input type="radio" v-model="pick" v-bind:value="a">
<!--选中时向vm.selected.number添加123 -->
<select v-model="selected">
  <option v-bind:value="{ number: 123 }">123</option>
</select>


```

##### 修饰符

* lazy: 在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步 (除了[上述](https://vuejs.bootcss.com/guide/forms.html#vmodel-ime-tip)输入法组合文字时)。你可以添加 `lazy` 修饰符，从而转变为使用 `change` 事件进行同步： 
* number: 如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符
* trim: 如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符 

```html
<input v-model.trim="msg">
```

### 组件

#### 组件注册

在组件中data需要为一个函数，这样可以保证每次调用组件时创建新的data对象。

###### 全局注册

```javascript
// 定义一个名为 button-counter 的新组件
Vue.component('button-counter', {
  data: function () {
    return {
      count: 0
    }
  },
  template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
})

Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })
```

 我们可以在一个通过 `new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 

```html
<div id="components-demo">
  <button-counter></button-counter>
</div>

<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```



###### 局部注册

如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。 

对于 `components` 对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是这个组件的选项对象。 

```html
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
<!--然后在 components 选项中定义你想要使用的组件-->
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```







#### 向子组件传值

通过props来传递值

```vue
Vue.component('blog-post', {
  props: ['title'],
  template: '<h3>{{ title }}</h3>'
})


<blog-post title="My journey with Vue"></blog-post>
<blog-post title="Blogging with Vue"></blog-post>
<blog-post title="Why Vue is so fun"></blog-post>
```

#### 监听子组件事件

通过  `postFontSize` 数据属性来监听事件

```vue
<!--父组件监听自定义的事件-->
<blog-post
  ...
  v-on:enlarge-text="postFontSize +=  $event"
></blog-post>
<!--子组件创建一个自定义的事件-->
<button v-on:click="$emit('enlarge-text', 0.1)">
  Enlarge text
</button>
```

#### 动态组件

```html
<!-- 组件会在 `currentTabComponent` 改变时改变 -->
<component v-bind:is="currentTabComponent"></component>
<!-- 失活的组件将会被缓存！-->
<keep-alive>
  <component v-bind:is="currentTabComponent"></component>
</keep-alive>

```

### 路由









## react

## angular

### 工程总览

#### 工程创建

```shell
npm i @angular/cli
ng new project_name   ##创建名为project——name的项目
ng new project_name --skip-install --style css --routing false  ##只生成文件不下载依赖
ng serve   ##启动服务
ng build   ##打包
ng lint ##扫描代码
ng g c component/component_name  ## 创建新的组件
ng g m Home --routing##创建路由模块
ng add ng-zorro-antd ##ui库

```

#### 项目目录

```
--e2e  测试目录
--src  源码目录
----assets  资源目录（存放图片，音频等）
----environments  环境目录
----app  主要逻辑代码目录
--editorconfig  编码风格设置
--angular.json  项目的定义文件
--browserslist  浏览器兼容设置(css)
--karma.conf.js  测试文件
--tsconfig.*  ts配置文件
--tslint.json  静态代码扫描
--polyfills.ts  浏览器兼容设置(js)
```

#### 项目结构

项目是由一个个模块构成的。每个模块包括该模块内容与相对应的路由模块。模块内容包括一个个组件、指令、管道、服务。

模块分为根模块，普通模块，共享模块。

```
--根模块---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-根路由模块
|-模块一---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-负责模块一的路由模块
|-模块二---组件一、指令一、管道一、服务一
|	   |--组件二、指令二、管道二、服务二
|-负责模块二的路由模块
|-共享模块---公用组件一、公用指令一、公用管道一
	     |--公用组件二、公用指令二、公用管道二
```



以下是模块与组件的关系，组件是最小渲染单元。

```javascript
//在app.module.ts中，配置所有组件
@NgModule({
  declarations: [//本模块中含有的组件
    AppComponent
  ],
  imports: [//依赖的其他模块
    BrowserModule
  ],
  providers: [],//对内需要暴露的服务
  bootstrap: [AppComponent]//启动的根组件，入口组件
})
```

而一个项目通常是由多个模板组成的。

#### 脏值检测

###### 定义

脏值检测是angular的一个基本机制，他保证了当angular的数据变化时可以更新视图。

###### 触发脏值检测的条件

* 浏览器事件，例如click，mouseover，keyup

* setTimeout和setInterval

* HTTP请求

###### 如何进行脏值检测

他将组件按照嵌套关系生成以可组件树，递归的查询每棵树上的绑定数据的值，如果有变化则更新视图。

在有父组件和子组件的生命周期中

```
子组<------更新输入型属性
      |---OnInit，DoCheck，OnChanges
      |   更新dom--------->父组件
      |---脏值检测（完成后会引发下面的周期）
      |---AfterViewCheck，AfterViewInit
```

脏值检测的时候，angular会从跟组件开始循环遍历，查看所有绑定数据的属性值有没有变化，且进行两次。

这也指明了我们不能在AfterViewCheck，AfterViewInit中对绑定的数据进行更改，因为如果在此更改后，脏值检测完成后，触发AfterViewCheck事件更改了值，紧接着触发第二次脏值检测，检测到值不一样了会抛出异常。

###### 默认策略与onpush策略

以上说的为默认政策，默认政策时，脏值检测当出发的时候会递归的查询所有组件，有时候可能会影响性能。onpush政策可以使当触发脏值检测的时候，只检查本组件的input变量有没有变化而忽略其他的改变。而input变量有来自于组件外，所以，将组件设置为onpush政策使得该组件变成了一个笨组件(木偶组件)，只用于单纯的展示。

要设置成onpush策略我们要在组件逻辑ts中加入如下：

```javascript
@Component({
	changeDetection:ChangeDetectionStrategy.onpush
})
```

但需要主义的使，路由的参数变化在默认策略之下，不会销毁这个组件而是重用这个组件，所以ngOnInit（我们默认数据的获取写在这里）只走一遍，这在默认模式下面没有问题，但在onpush模式下会被忽略，从而导致在改变路由参数之后，再改回来的时候，数据会无法获取到。

解决方法，我们将`private cd:ChangeDetectorRef`引入到类中，通过再函数末尾使用`this.cd.markForCheck()`来告诉组件此处发生了变化，需要更新数据。

### angular基础知识

#### 条件渲染

*ngFor：循环渲染

```html
<ul>
	<li *ngFor="let menu of menus;
		let i=index;  //索引
		let first=first;  //是否为第一个元素
        let last=last;   //是否为最后一个元素
        let odd=odd;   //是否为第奇数个
        let even=even;   //是否为第偶数个
        trackBy:trackElement;   //提升性能，后面借一个表达式或者函数
    " >
        <a herf="#">{{menu.title}}</a>
	</li>
</ul>
```

*ngIf：判断渲染

```html
<div *ngIf="条件">
    条件为真的内容
</div>

<div *ngIf="条件" else elseContent>
    条件为真的内容
</div>
<ng-template #elseContent>
    条件为假的内容
</ng-template>
```

#### 事件绑定

```html
<a
   herf="#"
   (click)='function(){}'
   >
</a>
```





#### 样式绑定

* 第一种：当后面的表达式成立，`.active`样式生效。适用于单个样式

  ```html
  <a
     herf="#"
     [class.active]="selectedIndex===i"
     >
  </a>
  ```

* 第二种：自由度拓展性最强的绑定方法

  ```html
  <a
     [ngClass]="{'active':true,'first':false}"
  ></a>
  ```

* 第三种：嵌入式样式，会覆盖其他样式。常用于动态改变某个css属性。

  ```html
  <a
  	[ngStyle]="{'color':somecolor,'font-size':somesize}"   
  ></a>
  ```

* 第四种：js操作dom去绑定(不推荐使用)

* 第五种：js使用rd2去绑定

  ```javascript
  (private elr:ElementRef,private rd2:Renderer2)=>{
  	this.rd2.setStyle(this.elr.nativeElement,'display','grid')
  }
  ```

eg：

* 在组件中有一个伪类`:host`,他的属性定义会应用到他的宿主（也就是他所在的组件本身），而不是模板中的元素。

#### 依赖注入

当我们定义一个类之后，想要应用这个类中的方法，就比如通过new一个他的实例然后使用。但是如果该类被标记了注入服务，那么我们在声明他的时候就不用在通过new去创建实例，而是可以直接声明类型后去使用。此时该类也变成了单利模式。

```javascript
@Injectable()//声明可注入
class Product{
    constructor(private name:string){}
}
@Injectable()
class PurchaseOrder{
    private product:Product;
    constructor(private product:Product){}
}

ngOnInit(){
    const injector=Injector.create({
        //在声明自己函数后，在此将自己的函数创建实例，供别人直接使用
        providers:[//依赖池：在此声明所有需要供用的函数
            {
                provide:Product,//标识符
                useFactory:()=>{
                	return newProduct('haha')
            	}
            },{
                provide:PurchaseOrder,
                useClass:Product,//去new的东西
                deps:[Product]本类中依赖的类
            }
        ]
    })
    console.log(this.injector.get(Product))//可以通过js方式获取该类
}


//此后如果我想用Product类，可以直接通过private product:Product的方式，而不用new了。
```

在angular中提供了更为简单的方式，不用我们自己通过`Injector.create`自行构造的，再将类暴露出去之后，可以直接通过在模块中设置providers属性中设置。

```javascript
@NgModule({
	declarations:[],
	providers:[
		PurchaseOrder,//如果无需工厂设置可以直接只写一个类名
		{
			provide:Product,
			useFactory:()=>{
				return newProduct('haha')
			}
		}
	],
	imports:[]
})
```

除了在模块中自己设置angular6以后的版本中还有一种更简单的设置方法，直接在服务创建的时候自行声明

```javascript
@Injectable({
    providedIn: 'root' //root代表跟模块，也可以指定模块
})
export class Product{
    constructor(private name:string){}
}
```

如果我们要提供的不是一个具体的类，而是一个值，我们可以这么写

```javascript
const injector=Injector.create({
        providers:[
            {
                provide:'baseUrl',
                useValue:'http://localhost'
            }
        ]
})
this.injector.get('baseUrl')
```

但是在大型项目中，使用字符串做名字是很危险的，极有可能造成命名重复，所以我们创建一个token来确保他的唯一性

```javascript
const token=new InjectionToken<string>('baseUrl')
const injector=Injector.create({
        providers:[
            {
                provide:token,
                useValue:'http://localhost'
            }
        ]
})
this.injector.get(token)
//此后如果我想用这个字符串，可以这样声明：
//@Inject(token) private baseurl:string
```









### 组件

#### 组件的封装

* 通过` ng g c component_name`生成新的组件

* 在新生成的组件中创建index.ts并暴露此组件

* 在使用的组件中引入组件

* 组件可以使用其ts文件中selector作为名字在其他地方直接使用

* 结构目录如下

  ```
  ---component
  	---index.ts
  	---scrollable
  		---index.ts
  		---scrollable.component.css
  		---scrollable.component.html
  		---scrollable.component.ts
  		---scrollable.component.spec.ts
  	---app.component.css
  	---app.component.html
  	---app.component.ts
  	---app.component.spec.ts
  	---app.module.ts
  
  ```

#### 组件的通讯

##### 子组件--->父组件  事件绑定

在子组件中

```javascript
export class ChildComponent {
    index:-1;
  	@Output() tabSelected=new EventEmitter();
  	handleSelect(index){
        this.tabSelected.emit(index)
  		 	
  	}
}
```

在父组件中

```html
<child_component (tabSelect)="handleTabSelected($event)"></child_component>

export class AppComponent {
  	handleTabSelected(index){
		console.log(index)
	}
}

```

##### 父组件--->子组件  属性绑定

在父组件中

```html
<!--定义变量-->
export class AppComponent {
  menus=[1,2,3]
}
<!--将menus变量传给子组件-->
<child_component [data]='menus'></child_component>
```

在子组件中

```html
<!--接收变量-->
export class ChildComponent {
  @Input() data=[]
}
<!--使用变量-->
<ul>
    <li *ngFor="let menu of data;">
		{{menu}}
    </li>
</ul>
```

#### 组件的生命周期



组件在使用前需要继承相关接口

```javascript
export class ScrollableTabComponent implements OnInit {//需要先继承
  constructor() { }
  ngOnInit() {
  }
}
```

#### 组件的投影

```html
<!--父组件中-->
<child_component>
	<p>
        hello
    </p>
</child_component>
<!--在子组件中，被嵌套的内容会显示在此标签的位置,select选择指定内容显示-->
<ng-content select="样式/html标签/指令"></ng-content>  
```

#### 组件类中引用模板的元素

```html
<!--在模板中,用#做一个唯一标识,一下分别时去一个普通元素，一个自定义元素，多个普通元素-->
<div #helloDiv>
    hello
</div>
<app-image-slider></app-image-slider>
<img #img *ngFor"let a of lists" [src]="a.src"/>
<!--在组件类中使用@ViewChild选择器选择。ElementRef是html的一个包装类-->
export class AppComponent{
	@ViewChild('helloDiv') helloDivRef:ElementRef;
	@ViewChild('ImageSliderComponent') imageSlider:ImageSliderComponent;
	@ViewChildren("img") imgs:QueryList<ElementRef>
    
    handleable(){
		console.log(helloDivRef.nativeElement) //元素本身
	}
}
```

#### 组件的双向绑定

双向绑定最常见的作用就是，在我们更新input输入内容的同时，input的内容会不断更新在另外一处地方。

在此之前我们已经可以达到双向绑定了，通过事件绑定+属性绑定来实现。

```html
<input type="text" [value]="username" (input)="username=$event.target.value">
```

在angular中还有更简单的方法。[(ngModel)]=“变量”，这其实就是一个语法糖。

首先需要引入FormsModule模块。

然后可以简写为

```html
<input type="text" [(ngModel)]="username"> 
```



### 模块

### 服务

### 管道

##### 内建管道

* json管道：`a|json` 转化为json格式

* data管道：`a| data: slice:1:3` 切割第一位到第三位

* date管道：`a| date:'MM-dd'` 将日期转化为月-日的格式

* currency管道：`a|currency 'CNY' :'symbol':'4.0-2'` 使用￥前缀，小数点前4位小数点后两位保留数 

* async管道：异步管道，例子如下

  ```
  
  ```

  

##### 自定义管道

通过`ng-pipe`在vscode中创建模板

```javascript
//设置倒计时管道
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({ name: 'appAgo' })
export class AgoPipe implements PipeTransform {
  transform(value: any): any {
    if (value) {
      const seconds = Math.floor((+new Date() - +new Date(value)) / 1000);
      if (seconds < 29) {
        // 小于 30 秒
        return '刚刚';
      }
      const intervals = {
        年: 3600 * 24 * 365,
        月: 3600 * 24 * 30,
        周: 3600 * 24 * 7,
        天: 3600 * 24,
        小时: 3600,
        分钟: 60,
        秒: 1
      };
      let counter = 0;
      for (const unitName in intervals) {
        if (intervals.hasOwnProperty(unitName)) {
          const unitValue = intervals[unitName];
          counter = Math.floor(seconds / unitValue);
          if (counter > 0) {
            return counter + ' ' + unitName + '前';
          }
        }
      }
    }
    return value;
  }
}

```







### 指令

指令分为三种：

* 组件：特殊的指令，带模板的指令
* 结构型指令（内建指令）：改变dom结构。例如ngIf、ngFor、ngSwitch
* 属性型指令（内建指令）：改变宿主行为。例如ngClass、ngStyle、ngModel



除了使用内建指令，我们还可以自己创建一个指令

```typescript
//创建一个属性指令
import { Directive, HostBinding } from '@angular/core';

/**
 * 指令可以理解为没有模版的组件，它需要一个宿主元素。
 * 推荐使用方括号 [] 指定 Selector，使它变成一个属性。
 */
@Directive({
  selector: '[appGridItem]'
})
export class GridItemDirective implements OnInit{
    contructors(private elr: ElementRef, private renderer: Renderer2){}
    ngOnInit():void {//注意修改属性的方法要放到oninit生命周期里执行 ，而不能放到contructor里面。
        this.rd2.setStyle(this.elr.nativeElement,'display','grid')
    }
}
```



如果单纯使用指令绑定样式和事件，angular提供了更简单的方法。

由于指令没有模板，所以他要寄宿在一个元素之上（宿主），`@HostBinding` 可以绑定宿主的属性或者样式，`@HostListener`可以绑定宿主的事件。

```javascript
export class GridItemDirective {
	@HostBinding('style.display') display = 'grid';
	@HostBinding('style.place-items') align = 'center';
/*
使用hostbinding绑定后，使得宿主的style.display与display变量相关联，同时变化。
*/
	@HostListener('click',['$event.target'])
   	handleClick(ev){console.log(ev)}
/*
使用hostlistener绑定后，第一个参数是事件类型，第二个参数是数组，写入数据依赖，当宿主触发了对一个事件后，会触发指令中的函数方法
*/
}

```









### 路由

##### 基本形式

通过`ng-router-appmodule`创建模板

```typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { RecommendContainerComponent } from './components';

const routes: Routes = [
    {path: '', redirectTo: 'home',pathMatch: 'full'},
    {path: 'home',component: RecommendContainerComponent1},
    {path: '**', component: RecommendContainerComponent2},
];
//''路径表示默认，**表示不识别的路径
@NgModule({
  imports: [RouterModule.forChild(routes)],//在此处导入模块
  exports: [RouterModule]
})
export class RecommendRoutingModule {}


//应用
//<router-outlet></router-outlet>
```

##### 路由的嵌套

当然路由也可以嵌套，加入home下面还有子路由,我们可以再子路由中设置

```typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { HomeContainerComponent, HomeDetailComponent } from './components';

const routes: Routes = [
  {
    path: 'home',
    component: HomeContainerComponent,
    children: [
      {
        /**
         * 路由节点可以没有 component
         * 一般用于重定向到一个默认子路由
         */
        path: '',
        redirectTo: 'hot',
        pathMatch: 'full'
      },
      {
        /**
         * 路径参数，看起来是 URL 的一部分
         */
        path: ':tabLink',
        component: HomeDetailComponent
      }
    ]
  }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class HomeRoutingModule {}

```

##### 路径参数

拼接在url上面的，叫做路径参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home','/spots']"></a>

this.router.navigate(['home','/spots'])

*url*

http://loaclhost:4200/home/sports

*取读*

this.route.paramsMap.subcribe(params=>{})

##### 路径对象参数

形似`name=val1`的参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home','/spots'，{name:'val1'}]"></a>

this.router.navigate(['home','/spots',{name:'val1'}])

*url*

http://loaclhost:4200/home/sports;name=val1

*取读*

this.route.paramsMap.subcribe(params=>{})

##### 路径查询参数

形似`?name=val1`的参数

*配置*

{path:':tabLink',component:component}

*激活*

<a [routerLink]="['/home']" [queryParms]={name:'val1'}></a>

this.router.navigate(['home'],{queryParms:{name:'val1'}})

*url*

http://loaclhost:4200/home/sports;name=val1

*取读*

this.route.queryParamsMap.subcribe(params=>{})

##### 点击触发样式

我们可以通过`routerLinkActive`属性在标签点击触发路由的时候添加类名

```html
<a 
   [routerLink]="['/home']" 
   [queryParms]={name:'val1'}
   routerLinkActive="active"
></a>
```



### 网络接口对接

##### HttpClient

* 在根模块导入HttpClientModule
* 在构造中注入HttpClient
* 订阅后发送请求

```javascript
//在根模块引入后，在其他模块中也可以使用
export class HomeService{
    constructor(private http:HttpClient){}
    getData(){
        //通过泛型的形式，将他返回的数据进行格式转换，此处可以是string，也可以是其他自行定义的类型
        return this.http.get<string>(url,{
            params:{icode:123}
        })
    }
}
//http是一种异步操作
//这个时候getData返回的数据类型是
//在使用他的时候为
export class Home{
    constructor(private serve:HomeService){}
    let _data='';
    ngOnInit(){
        this.serve.subscribe(tabs=>{
         	this._data=tabs;   
        })
    }
}
```

##### http拦截器 httpInterceptor

在http获取到数据之前，我们先将其进行一步处理，然后再交给httpclient去处理。在请求和访问的时候都可以进行拦截。

在请求中，例如要为很多http请求统一加入一个请求参数而无需一个一个加。

通过`ng-http-interceptor`在vscode中生成模板

```javascript
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest
} from '@angular/common/http';
import { environment } from 'src/environments/environment';

@Injectable()
export class ParamInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    // 对请求消息进行处理
    const modifiedReq = req.clone({
      //将原来的req克隆下来，并为他加入查询参数
      setParams: { icode: environment.icode }
    });
    //交给下一个拦截器去处理，因为在angular中可能有多个拦截器
    return next.handle(modifiedReq);
  }
}
```

完成设置后，我们要在根模块将它引入

```typescript
@NgModule({
  declarations: [AppComponent],
  imports: [],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: NotificationInterceptor,
      multi: true
    }
  ],
  bootstrap: []
})
```



同理，我们也可以拦截请求到的数据，也就是respond的数据。

例如我们要设置，当请求成功的时候弹出消息。

```javascript
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpInterceptor,
  HttpHandler,
  HttpRequest,
  HttpResponse
} from '@angular/common/http';
import { tap } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class NotificationInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    // 对响应消息进行处理
    return next.handle(req).pipe(
      tap((event: HttpEvent<any>) => {
        if (
          event instanceof HttpResponse &&
          event.status >= 200 &&
          event.status < 300
        ) {
          console.log('[此处假装弹出消息] 请求成功！');
        }
      })
    );
  }
}
```

完成后同样在根模块引入。

##### rxjs 响应式编程类库

###### 基础概念

rx要把事件或者数据看成一个流，随着事件流中的元素的变化随之做出相应的动作。

流的种类：无线、有限、单个、空

流的状态：next（得到流的数据之后的处理）、error（发生错误的处理）、complete（无论成功与否，最后都要执行的处理）

此外，所有的流都是异步的。

rx中流的类型用`observable`类型来表示。

rx最强大的地方之一，就是他拥有方便的操作符。

###### 操作符

在路由参数接受的时候，我们运用的就是`observable`类型，如下例子

```javascript
paramData;
ngOnInit(){
	this.route.paramMap.subscribe(params=>{
    	this.paramData=params.get('tabLink')
	})
}
```

使用在模板中

```html
<div *ngIf="paramData==='home'">
    <p>
        hello
    </p>
</div>
```



上面的代码中，我们获取到params参数中，获取到tabLink属性，我们也可以添加管道，通过操作符改造。

```javascript
paramData;
ngOnInit(){
    this.route.paramMap
    .pipe(
		filter(params=>params.has('tabLink')),
    	map(params=>params.get('tabLink'))
	)
    .subscribe(tabLink=>{
    	this.paramData=tabLink;
	})
}
```

应用在模板中同上。

但是在angular中，为了更好的兼容rx，我们可以直接将一个变量声明为流

```javascript
//当变量作为流的时候，我们习惯在命名上加上一个$用于区分
paramData$:Observable<string>;
ngOnInit(){
    this.paramData=this.route.paramMap
    .pipe(
		filter(params=>params.has('tabLink')),
    	map(params=>params.get('tabLink'))
	)
}
```

使用在模板中时，由于这是一部操作，所以在一开始的时候paramData和‘home’的数据类型不同，所以我们通过异步管道实现它。

```html
<div *ngIf="(paramData | async)==='home'">
    <p>
        hello
    </p>
</div>
```





## react native

### 项目启动

在电脑装有`node10`、`python2*`、`sdk`、`jdk`、`gradle`、`nox`的环境下

* 直接使用`npx react-native init AwesomeProject `,也可以先下载脚手架`npm -g install react-native-cli`,然后安装项目`react-native  init AwesomeProject ` 
* 确保在`nox`的`bin`目录下的`nox_adb version`与全局下的`adb version`是一个版本，如不是，则复制过去
* 在命令行输入 `nox_adb connect 127.0.01：62001`
* 在命令行输入 `adb devices`
* 进入项目中打包，`react-native run-android` ,并输入`npm start`
* 打开`nox`模拟器，在`setting`中设置`IP`为`172.17.100.2：8081`
* 重启模拟器

再次启动时，直接运行`npm start`然后打开模拟器上的`apk`就可以了

### 样式

```jsx
import React, { Component } from 'react';
import { StyleSheet, Text, View } from 'react-native';

export default class LotsOfStyles extends Component {
  render() {
    return (
      <View>
        <Text style={styles.red}>just red</Text>
        <Text style={styles.bigBlue}>just bigBlue</Text>
        <Text style={[styles.bigBlue, styles.red]}>bigBlue, then red</Text>
        <Text style={[styles.red, styles.bigBlue]}>red, then bigBlue</Text>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  bigBlue: {
    color: 'blue',
    fontWeight: 'bold',
    fontSize: 30,
  },
  red: {
    color: 'red',
  },
});

```





### 常见标签

View

> 创建 UI 时最基础的组件，直接对应一个平台的原生视图，IOS中的 UIView、Android中的android.view和Web中的div等

Text

> - 一个用于显示文本的 RN 组件，支持嵌套、样式，以及触摸处理，可继承样式
> - `<Text>`元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。

Image

> 用于显示多种不同类型图片的 React 组件，包括网络图片、静态资源、base64图片等。

```JSx
export default class DisplayAnImage extends Component {
  render() {
    return (
      <View>
        <Image
          source={require('../assets/logo.png')}
        />
        <Image
          style={{width: 50, height: 50}}
          source={{uri: 'https://facebook.github.io/react-native/img/tiny_logo.png'}}
        />
        <Image
          style={{width: 66, height: 58}}
          source={{uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg=='}}
        />
      </View>
    );
  }
}

```

> ### 属性：resizeMode
>
> 决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小。默认值为`cover`。
>
> - `cover`: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都大于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。
> - `contain`: 在保持图片宽高比的前提下缩放图片，直到宽度和高度都小于等于容器视图的尺寸（如果容器有 padding 内衬的话，则相应减去）。**译注**：这样图片完全被包裹在容器中，容器中可能留有空白。
> - `stretch`: 拉伸图片且不维持宽高比，直到宽高都刚好填满容器。
> - `repeat`: 重复平铺图片直到填满容器。图片会维持原始尺寸，但是当尺寸超过容器时会在保持宽高比的前提下缩放到能被容器包裹。
> - `center`: 居中不拉伸。

ImageBackground

> 添加背景色，必须指定 width 和 height，通过 source 属性指定 背景图片

```jsx
 <ImageBackground 
     source={...} 
     style={{width: '100%', height: '100%'}}
 >
    <Text>Inside</Text>
 </ImageBackground>
```

TextInput

> - 用户在应用中通过键盘输入文本的基本组件,必须通过 onChangeText事件来读取用户的输入
> - value
> - onChangeText
> - onSubmitEditing
> - onFocus

ScrollView

> 封装了平台的ScrollView（滚动视图）的组件

Button

> 跨平台的按钮组件

```jsx
<Button
  onPress={()=>{}}
  title="按钮"
  color="#841584"
/>
```

TouchableOpacity

> 不透明度会变化的按钮

FlatList

> 高性能的简单列表组件

```jsx
<FlatList
    data={[{key: 'a'}, {key: 'b'}]}
    numColumns={2} //水平多少个元素
    initialNumToRender={6} //每次加载多少个
    onRefresh={()=>{}} //下拉刷新
    refreshing={false} //下拉刷新时的加载样式，此处应手动更改，在触发下拉加载时将值改为true，加载完成后改为false
    onEndReached={()=>{}} //上拉加载
    onEndReachedThreshold:10 //距离底部多少距离触发上拉下载函数
    renderItem={({item}) => <Text>{item.key}</Text>}
/>
```

SectionList

> 高性能的简单列表组件，在每组数据上方可以加一个表头样式（自定义标签）

StatusBar

状态栏

```html
<StatusBar
   animated={true} //指定状态栏的变化是否应以动画形式呈现。目前支持这几种样式：backgroundColor, barStyle和hidden  
   hidden={false}  //是否隐藏状态栏。  
   backgroundColor={'red'} //状态栏的背景色  
   translucent={true}//指定状态栏是否透明。设置为true时，应用会在状态栏之下绘制（即所谓“沉浸式”——被状态栏遮住一部分）。常和带有半透明背景色的状态栏搭配使用。  
    barStyle={'light-content'} // enum('default', 'light-content', 'dark-content')   
            >
</StatusBar>
```



### 路由

安装

```shell
yarn add react-native-router-flux
```



切换路由后，之前的路由在状态会保存。

```html
<!--App组件中-->
<Router>
      <Scene key="root">
        <Scene key="msg" component={Msg}/>   ## 默认页
          <Scene key="doc" title="文档" titleStyle={{}} renderRightButton={} component={Doc}/>
      </Scene>
</Router>

<!--Msg组件中-->
<Button title="跳到Doc" onPress={()=>Actions.doc({count:1})/>
<!--Doc组件-->
<view>
	<Text>{{this.props.count}}</Text>
</view>

```

我们也可以实现tab栏

```jsx
<Router>
      <Scene key="root">
        <Tabs key="tabbar" hideNavBar activeTintColor="red">
        	<Scene key="msg" title="消息" icon={()=><Image/>}>
            	<Scene key="msgs" component={Msg}/>
                <Scene key="msgsDetail" component={MsgDetail} hideTabbar/>
            </Scene>
        	<Scene key="doc" title="文档">
            	<Scene  key="docs" component={Doc}/>
            </Scene>
        </Tabs>
      </Scene>
</Router>

```

#### Tabs 功能

```html
...
import { Tabs } from 'react-native-router-flux';

//设置tab选中时的字体颜色和标题
const TabIcon = ({focused , title}) => {
  return (
    <Text 
        style={{color: focused  ? 'blue' : 'black'}}
    >
          {title}
    </Text>
  );
};
 
const Root = () => {
  return (
      <Router>
        <Scene hideNavBar>
          <Tabs
            key="tabbar"
            // 是否显示标签栏文字
            showLabel={false}
            tabBarStyle={{backgroundColor: "#eee"}}
            //tab选中的颜色
            activeBackgroundColor="white"
            //tab没选中的颜色
            inactiveBackgroundColor="red"
          >
            <Scene
              key="one"
              icon={TabIcon}
              component={PageOne}
              title="PageOne"
            />

            <Scene
              key="two"
              component={PageTwo}
              title="PageTwo"
              icon={TabIcon}
            />

            <Scene
              key="three"
              component={PageThree}
              title="PageThree"
              icon={TabIcon}
            />
          </Tabs>
      </Scene>
  </Router>)
};
```

#### Drawer

侧边栏

```html
<Drawer
    key="drawer"
    drawerPosition="left/right"
    drawerImage={图片源}
    drawerIcon={}
    contentComponent={DrawerContent}
	drawerWidth={400}
    hideDrawerButton
>
    <Tabs></Tabs>
</Drawer>
```

#### Lightbox

路由转跳从下方出现

```html
<Router>
  <Lightbox>
    <Scene key="root">
      ...
    </Scene>
    <Scene key="light_box" component={MyLightbox} />
  </Lightbox>
</Router>
```

#### Modal

路由转跳以整个新页面的形式

```html
<Router>
  <Modal>
    <Scene key="root">
      ...
    </Scene>
    <Scene key="statusModal" component={StatusModal} />
    <Scene key="errorModal" component={ErrorModal} />
    <Scene key="loginModal" component={LoginModal} />
  </Modal>
</Router>
```

#### Actions

- [key] : Actions.key( ) or Actions[key].call( )
- pop( )
- replace( )
- refresh( )
- reset( )
- currentScene: 返回当前的 Scene
- drawerOpen
- drawerClose

### 第三方组件

#### ActivityIndicator

```html
<ActivityIndicator size="large" color="#0000ff" />
```

#### Animated

> 创建动画
>
> 使用组件前加Animated

```javascript
//1. 创建样式初始值
this.state = {
    	opacity: new Animated.Value(0)
}
//2.定时样式值变化
Animated.timing(
  // timing方法使动画值随时间变化
  this.state.opacity, // 要变化的动画值
  {
    	toValue: 1, // 最终的动画值
      	duration: 500,
      	delay: 0
  },
).start( callback ); // 动画完成后可调用 callback 
// *timing可以换成spring，有反弹效果动画
```

#### WebView

> 

```html
yarn add react-native-webview
react-native link react-native-webview

import { WebView } from 'react-native-webview';

<WebView source={{ uri: 'https://www.baidu.com' }} />;
```

#### [react-native-image-picker](https://github.com/react-native-community/react-native-image-picker)

> 打开摄像机功能

- 安装并 link

```shell
yarn add react-native-image-picker

react-native link react-native-image-picker
```

- 在 `android\app\src\main\AndroidManifest.xml` 添加

```html
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
```

- 在 `android\app\src\main\Java\com\projectname\MainActivity` 中添加

```javascript
//开头
import com.imagepicker.permissions.OnImagePickerPermissionsCallback; // <- add this import
import com.facebook.react.modules.core.PermissionListener; // <- add this import

// MainActivity 中添加
 private PermissionListener listener;
```

- 使用

```
import ImagePicker from 'react-native-image-picker';

const options = {
  title: 'Select Avatar',
  customButtons: [{ name: 'fb', title: 'Choose Photo from Facebook' }],
  storageOptions: {
    skipBackup: true,
    path: 'images',
  },
};

ImagePicker.showImagePicker(options, (response) => {
      if (response.didCancel) {
        return;
      } else if (response.error) {
        console.log('Error:', response.error);
      } else if (response.customButton) {
        console.log('custom:', response.customButton);
      } else {
          
        const source = { uri: response.uri };
        this.setState({
          avatarSource: source,
        });
      }
    });

<Image source={this.state.avatarSource} style={{width:200,height:200}} />
```

#### [react-native-image-crop-picker](https://github.com/ivpusic/react-native-image-crop-picker)

```
yarn add react-native-image-crop-picker
react-native link react-native-image-crop-picker

ImagePicker.openCamera({
  width: 300,
  height: 400,
  cropping: true,
}).then(image => {
  this.setState({imgUrl:image.path})
});
```

#### [react-native-button](https://github.com/ide/react-native-button)

```
yarn add react-native-button

import Button from 'react-native-button';

<Button 
    style={{
        width:100,height: 40,
        borderRadius: 20,
        textAlignVertical: 'center',
        backgroundColor:'red',
        color: '#fff'
    }}
>文本</Button>
```

#### [react-native-message-bar](https://github.com/KBLNY/react-native-message-bar)

```
yarn add react-native-message-bar

import React from 'react';
import { MessageBar, MessageBarManager } from 'react-native-message-bar';

export default class extends React.Component {
  componentDidMount() {
  MessageBarManager.registerMessageBar(this.refs.alert);
  }

  componentWillUnmount() {
    MessageBarManager.unregisterMessageBar();
  }
    
  render() {
    return <MessageBar ref="alert" />;
  }
}
```

### [react-native-vector-icons](https://github.com/oblador/react-native-vector-icons)

[图标地址](https://oblador.github.io/react-native-vector-icons/)

```
 //1. 安装
yarn add react-native-vector-icons
 //2. link，执行完在 项目\android\app\src\main\assets\fonts 文件夹下会多出 ttf 格式的图标文件
react-native link react-native-vector-icons
 //3. 卸载 App，重新 react-native run-android
 //4. 引入 Icon 组件，注意后面的 / ,后面是哪个文件，将来就在 图标地址 哪一栏找图标名字
import Icon from 'react-native-vector-icons/FontAwesome';

<Icon name="rocket" size={30} color="#900" />;
```

#### [react-native-swiper](https://github.com/leecade/react-native-swiper)

```
yarn add react-native-swiper@nightly

import Swiper from 'react-native-swiper';

<Swiper style={styles.wrapper} showsButtons={true}>
    <View style={styles.slide1}>
        <Text style={styles.text}>Hello Swiper</Text>
    </View>
    <View style={styles.slide2}>
        <Text style={styles.text}>Beautiful</Text>
    </View>
    <View style={styles.slide3}>
        <Text style={styles.text}>And simple</Text>
    </View>
</Swiper>
```

### 尺寸

* px：图片中最小的一格

* dpi（dot per inch）：每英寸上有多少个小格，格越多越清晰

* dp：安卓开发中使用的单位。1dp=像素密度为160dpi时1px的大小

```javascript
const {width,height,scale} = Dimensions.get('window')
/*
width屏幕宽度
height屏幕高度
scale像素密度与160的比值，例如在320dpi的像素密度下，1dp=2px
*/
```

### 布局技巧

弹性盒子

```css
/*父组件中*/
{
    flexDirection:'row', /*使子元素横向布局*/
    justifyContent:'space-evenly'/*间隔均分*/
}
```

元素居中

```css
{
    alignItems:"center"/*垂直居中*/
    justifyContent:'space-evenly'/*当空间只有一个元素时，水平居中*/
}
```

横排元素超出换行

```javascript
{
	flexWarp:'wrap'
}
```

返回键设置

```javascript
  BackHandler.addEventListener('back', () => {
    console.log(tag)
    if (tag) BackHandler.exitApp();//使用该方法退出app
    tag = true;
    setTimeout(() => {
      tag = false
    }, 1000)
    return true;//当返回为true时，按返回键不会退出

  })
```



### 本地存储

`AsyncStorage`组件用法

```javascript
AsyncStorage.setItem('userName':'helloword',()=>{/*回调函数*/})//存储键值对
AsyncStorage.setItem('userName').then((res)=>console.log(res))//返回一个promise
```



### 打包

1、生成一个签名密钥

```
 keytool -genkeypair -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```

> 这条命令会要求你输入密钥库（`keystore`）和对应密钥的密码，然后设置一些发行相关的信息。最后它会生成一个叫做`my-release-key.keystore`的密钥库文件。
>
> 在运行上面这条语句之后，密钥库里会生成一个单独的密钥，有效期为 10000 天。--alias 参数后面的别名将来为应用签名时需要用到，所以必须记住这个别名。

2、设置 `gradle` 变量

> 1. 把`my-release-key.keystore`文件放到你工程中的`android/app`文件夹下
>
> 2. 编辑项目目录`/android/gradle.properties`，加上如下代码
>
>    ```
>    MYAPP_RELEASE_STORE_FILE=my-release-key.keystore
>    MYAPP_RELEASE_KEY_ALIAS=my-key-alias
>    MYAPP_RELEASE_STORE_PASSWORD=*****
>    MYAPP_RELEASE_KEY_PASSWORD=*****
>    ```

3、把签名配置加入到项目的 `gradle` 配置中

> 编辑项目目录下的`android/app/build.gradle`，添加如下签名配置：
>
> ```
> ...
> android {
>     ...
>     defaultConfig { ... }
>     signingConfigs {
>         release {
>             if (project.hasProperty('MYAPP_RELEASE_STORE_FILE')) {
>                 storeFile file(MYAPP_RELEASE_STORE_FILE)
>                 storePassword MYAPP_RELEASE_STORE_PASSWORD
>                 keyAlias MYAPP_RELEASE_KEY_ALIAS
>                 keyPassword MYAPP_RELEASE_KEY_PASSWORD
>             }
>         }
>     }
>     buildTypes {
>         release {
>             ...
>             signingConfig signingConfigs.release
>         }
>     }
> }
> ...
> ```

4、生成发行` APK` 包

> 进到项目的 android 目录，执行如下命令
>
> ```
> ./gradlew assembleRelease
> ```

5、更换 logo 图标

> 将项目` android\app\src\main\res`下的文件夹中图片都换掉，重新打包即可。
>
> 可用如下地址生成各个尺寸的图片。
>
> 地址：https://icon.wuruihong.com/

6、更换项目名称

> 将项目目录下的 `android\app\src\main\res\values` 中的 `strings.xml` 中的名称改掉即可

### 配置ts环境

- 使用 `TypeScript` 模板创建新项目

```
react-native init MyApp --template react-native-template-typescript
```

- 现有项目添加 TypeScript

  1. ```
     yarn add --dev typescript @types/jest @types/react @types/react-native @types/react-test-renderer
     ```

  2. 在项目根目录下创建一个 TypeScript 配置文件（**tsconfig.json**）

     ```
     {
       "compilerOptions": {
         "allowJs": true,
         "allowSyntheticDefaultImports": true,
         "esModuleInterop": true,
         "isolatedModules": true,
         "jsx": "react",
         "lib": ["es6"],
         "moduleResolution": "node",
         "noEmit": true,
         "strict": true,
         "target": "esnext"
       },
       "exclude": [
         "node_modules",
         "babel.config.js",
         "metro.config.js",
         "jest.config.js"
       ]
     }
     ```

  3. 在项目根目录创建一个**jest.config.js**文件

     ```
     module.exports = {
       preset: 'react-native',
       moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
     };
     ```

  4. 重命名一个 JavaScript 文件为 ***.tsx**







